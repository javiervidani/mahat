# שאלה 8

## שאלון 97104, קיץ תשפ"ד – 2024 – מועד א'

**חלק ב' - ענו על 2 מבין השאלות 8-11 (ערך כל שאלה – 15 נקודות)**

## שאלה 8 (15 נקודות)

נתונה הגדרה הבאה:
"פָּלִינְדְרוֹם הוא רצף ערכים שקריאתו מימין לשמאל ומשמאל לימין היא זהה".

דוגמאות לרשימות שהן פלינדרומים:
[1,3,10,3,1], [5,2,2,5], [10,10,10,10], [1]

### א. (6 נק')
כתבו פעולה המקבלת רשימה של מספרים שלמים ובודקת אם היא "פלינדרום".

כותרת הפעולה:
```java
public static boolean isPalindrom(int[] arr)
```

נתונה הגדרה נוספת:
"פלינדרום של ערכים זוגיים" הוא רצף מספרים שלמים שיש בו רק ערכים זוגיים שקריאתו מימין לשמאל ומשמאל לימין היא זהה.

דוגמאות לפלינדרומים של ערכים זוגיים (הערכים המודגשים):
[1,3,**2**], [**10**,3,**4**,5,7,**4**,**10**], [3,5,7,1], [5,**2**,**2**,5], [1,3,**10**,3,1,**10**]

### ב. (6 נק')
כתבו פעולה המקבלת רשימה של מספרים שלמים ובודקת אם היא "פלינדרום של ערכים זוגיים".

כותרת הפעולה:
```java
public static boolean isEvenPalindrom(int[] arr)
```

### ג. (3 נק')
מהן סיבוכיות הפעולות שכתבתם בסעיפים א' ו-ב'. הסבירו את תשובתכם.

## פתרון

### סעיף א (6 נקודות)

```java
public static boolean isPalindrom(int[] arr) {
    int len = arr.length;
    for (int i = 0; i < len / 2; i++)
        if (arr[i] != arr[len - 1 - i])
            return false;
    return true;
}
```

**פתרון נוסף:**

```java
public static boolean isPalindrom(int[] arr) {
    int i = 0, j = arr.length - 1;
    while (i < j) {
        if (arr[i] != arr[j])
            return false;
        i++;
        j--;
    }
    return true;
}
```

### סעיף ב (6 נקודות)

```java
public static boolean isEvenPalindrom(int[] arr) {
    int len = arr.length;
    int[] evenArr = new int[len];
    int evenLength = 0;
    
    for (int i = 0; i < len; i++)
        if (arr[i] % 2 == 0)
            evenArr[evenLength++] = arr[i];
            
    int[] finalEvenArr = new int[evenLength];
    for (int i = 0; i < evenLength; i++)
        finalEvenArr[i] = evenArr[i];
        
    return isPalindrom(finalEvenArr);
}
```

**פתרון נוסף:**

```java
public static boolean isEvenPalindrom(int[] arr) {
    int i = 0, j = arr.length - 1;
    while (i < j) {
        if (arr[i] % 2 != 0) i++;
        else if (arr[j] % 2 != 0) j--;
        else {
            if (arr[i] != arr[j])
                return false;
            i++;
            j--;
        }
    }
    return true;
}
```

### סעיף ג (3 נקודות)

שניהם O(n) כאשר n הוא אורך המערך.

---
## 📚 הסבר התרגיל – כיצד לפתור?

### מהי הבעיה?
**פלינדרום** = רצף זהה משמאל לימין ומימין לשמאל.  
**פלינדרום של ערכים זוגיים** = רק הערכים הזוגיים יוצרים פלינדרום.

### אלגוריתם:

**סעיף א - isPalindrom:**
```java
public static boolean isPalindrom(int[] arr) {
    int len = arr.length;
    for (int i = 0; i < len / 2; i++)
        if (arr[i] != arr[len - 1 - i])
            return false;
    return true;
}
```

**לוגיקה:**
1. השווה איבר ראשון (i=0) לאיבר אחרון (len-1)
2. השווה איבר שני (i=1) לאיבר לפני אחרון (len-2)
3. המשך עד אמצע המערך (i < len/2)
4. אם נמצאה אי-התאמה → `return false`
5. אם כל ההשוואות עברו → `return true`

**דוגמאות:**
- `{1,3,10,3,1}` → השוואות: 1==1 ✅, 3==3 ✅, 10==10 ✅ → פלינדרום
- `{5,2,2,5}` → 5==5 ✅, 2==2 ✅ → פלינדרום
- `{1,2,3}` → 1≠3 ❌ → לא פלינדרום

**גישה חלופית עם שני מצביעים:**
```java
int i = 0, j = arr.length - 1;
while (i < j) {
    if (arr[i] != arr[j])
        return false;
    i++;
    j--;
}
return true;
```

**סעיף ב - isEvenPalindrom:**

**גישה 1 - יצירת מערך חדש:**
```java
1. צור מערך evenArr בגודל arr.length
2. העתק לתוכו רק ערכים זוגיים (arr[i] % 2 == 0)
3. צור מערך finalEvenArr בגודל מדויק (evenLength)
4. העתק את הערכים הזוגיים
5. קרא ל-isPalindrom(finalEvenArr)
```

**דוגמה:**
- `arr = {1,3,2}` → `evenArr = {2}` → אורך 1 → תמיד פלינדרום ✅
- `arr = {10,3,4,5,7,4,10}` → `evenArr = {10,4,4,10}` → פלינדרום ✅
- `arr = {5,2,2,5}` → `evenArr = {2,2}` → פלינדרום ✅

**גישה 2 - בדיקה ישירה (אופטימלית):**
```java
int i = 0, j = arr.length - 1;
while (i < j) {
    if (arr[i] % 2 != 0) i++;       // דלג על אי-זוגי משמאל
    else if (arr[j] % 2 != 0) j--;  // דלג על אי-זוגי מימין
    else {
        if (arr[i] != arr[j])       // בדוק זוגיים
            return false;
        i++;
        j--;
    }
}
return true;
```

**לוגיקה של גישה 2:**
- התעלם מערכים אי-זוגיים
- השווה רק זוגיים כאילו הם המערך היחיד
- דוגמה: `{1,10,3,4,5,7,4,10}` → בודק 10 מול 10 ✅, 4 מול 4 ✅

**סעיף ג - סיבוכיות:**
- **isPalindrom**: O(n) - לולאה אחת עד n/2
- **isEvenPalindrom גישה 1**: O(n) - 2 לולאות לינאריות + קריאה ל-isPalindrom
- **isEvenPalindrom גישה 2**: O(n) - לולאה אחת

### 🎯 מה להקפיד:

✅ **תנאי קצה:**
- מערך ריק: אורך 0 → פלינדרום (אין מה לבדוק) ✅
- מערך עם איבר אחד: תמיד פלינדרום ✅
- כל המערך אי-זוגי: evenArr ריק → פלינדרום (או תלוי בהגדרה)
- מערך זוגי בלבד: בדיקה רגילה

✅ **טעויות נפוצות בסעיף א:**
- לולאה עד `i < len` במקום `i < len/2` → בודק כל זוג פעמיים
- חישוב שגוי של האינדקס הנגדי: `arr[len-i]` במקום `arr[len-1-i]`
- אי-טיפול במערך באורך אי-זוגי (איבר אמצעי לא צריך בדיקה)

✅ **טעויות נפוצות בסעיף ב גישה 1:**
- שכחה ליצור מערך finalEvenArr בגודל מדויק → יהיה אפסים מיותרים
- לא אתחול evenLength לפני שימוש: `evenArr[evenLength++]`
- אי-בדיקת מקרה שאין ערכים זוגיים בכלל

✅ **טעויות נפוצות בסעיף ב גישה 2:**
- המשך לולאה גם כש-i>=j → בדיקות מיותרות
- שכחת דילוג על אי-זוגיים ובדיקתם כחלק מהפלינדרום
- דילוג על שני הצדדים יחד במקום בנפרד

✅ **דוגמאות בדיקה:**
- `{1,3,10,3,1}` → פלינדרום רגיל ✅, זוגיים: {10} → פלינדרום זוגי ✅
- `{10,3,4,5,7,4,10}` → לא פלינדרום רגיל ❌, זוגיים: {10,4,4,10} → פלינדרום זוגי ✅
- `{3,5,7,1}` → לא פלינדרום רגיל ❌, אין זוגיים → פלינדרום זוגי ✅ (ריק)
- `{2,4,2}` → פלינדרום רגיל ✅, זוגיים: {2,4,2} → לא פלינדרום זוגי ❌

---