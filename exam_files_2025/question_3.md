# שאלה 3

## שאלון 97104, קיץ תשפ"ה – 2025 – מועד א'

## שאלה 3 (12 נקודות)

נתונה הפעולה what:

```java
public static int what(int[] arr) {
    int c = 0;
    int m = 0;
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] % 2 == 0) {
            c++;
        } else {
            if (c > m) {
                m = c;
            }
            c = 0;
        }
    }
    if (c > m)
        return c;
    return m;
}
```

### א. (4 נק')
נתון מערך arr = {12, 6, 3, 17, 4, 5, 2, 8, 10, 13}.
עקבו אחרי זימון what(arr) ורשמו מה תהיה תוצאת הזימון. יש להראות מעקב אחרי הביצוע!

### ב. (3 נק')
תנו דוגמה למערך arr בגודל שישה תאים הכולל מספרים שלמים שונים זה מזה, שעבורו הפעולה what תחזיר את הערך ארבע.

### ג. (3 נק')
מהו הערך הקטן ביותר שהפעולה what יכולה להחזיר? תנו דוגמה למערך arr בגודל שישה תאים הכולל מספרים שלמים שונים זה מזה, שעבורו הפעולה what תחזיר ערך זה.

### ד. (2 נק')
מה מבצעת הפעולה what באופן כללי?

## פתרון

### סעיף א (4 נק')

```
arrA = {12, 6, 3, 17, 4, 5, 2, 8, 10, 13}

i  | arr[i] | זוגי? | c | m | הערות
---|--------|-------|---|---|-------
0  | 12     | כן    | 1 | 0 | זוגי → c++
1  | 6      | כן    | 2 | 0 | זוגי → c++
2  | 3      | לא    | 0 | 2 | אי-זוגי → m מעודכן ל-2
3  | 17     | לא    | 0 | 2 | אי-זוגי → אין שינוי
4  | 4      | כן    | 1 | 2 | התחלה של רצף חדש
5  | 5      | לא    | 0 | 2 | אי-זוגי → אין שינוי
6  | 2      | כן    | 1 | 2 | התחלה של רצף חדש
7  | 8      | כן    | 2 | 2 | המשך רצף
8  | 10     | כן    | 3 | 2 | המשך רצף
9  | 13     | לא    | 0 | 3 | אי-זוגי → m מעודכן ל-3

what(arrA) = 3
```

### סעיף ב (3 נק')

**דוגמה למערך שיחזיר 4:**

```java
{2, 4, 6, 8, 3, 1}
```

יחזיר 4

### סעיף ג (3 נק')

**הערך הקטן ביותר:** 0

**דוגמה למערך שיחזיר 0:**

```java
{1, 3, 5, 7, 9, 11}
```

יחזיר 0

### סעיף ד (2 נק')

**הסבר:** הפעולה מחשבת את האורך של רצף המספרים הזוגיים הרצוף הארוך ביותר במערך.

---
## 📚 הסבר התרגיל – כיצד לפתור?

### מהי הבעיה?
מצא את **רצף מספרים זוגיים רציפים הארוך ביותר** במערך. פעולה זו סופרת כמה זוגיים בזה אחר זה, ומחזיר את הרצף הארוך ביותר שנמצא.

דוגמה: `{12, 6, 3, 17, 4, 5, 2, 8, 10, 13}`
- 12, 6: רצף באורך 2
- 3: איזוגי → מחסום, m = 2
- 17: איזוגי → מחסום
- 4: התחלת רצף חדש
- 5: איזוגי → מחסום, m = 2
- 2, 8, 10: רצף באורך 3
- 13: איזוגי → מחסום, m = 3
- **תוצאה**: 3

### שלבי פתרון (אלגוריתם):

**שלב 1 – אתחול:**
- `c = 0` - מונה לרצף הנוכחי
- `m = 0` - הערך המקסימלי שהוצא עד כה

**שלב 2 – לולאה על המערך:**
- אם `arr[i]` זוגי (`% 2 == 0`): הגדל את `c`
- אם `arr[i]` איזוגי:
  - אם `c > m`: עדכן `m = c` (מצאנו רצף ארוך יותר)
  - אפס את `c` (סיימנו רצף נוכחי)

**שלב 3 – בדיקה בסוף:**
- אם הרצף האחרון ארוך מהמקסימום, עדכן את `m`

**שלב 4 – פלט:**
- החזר את `m` (אורך הרצף הארוך ביותר)

### דגשים חשובים:
- יש **לעדכן את `m` כל פעם שנתקלים בתו איזוגי או בסוף המערך**
- **אין להשתמש בשני מערכים** - פעולה זו דורשת דרך מעקב אחת בלבד
- **בדיקה לאחר הלולאה חשובה** - כדי לתפוס את הרצף האחרון אם הוא הארוך ביותר

### תנאי קצה:
- מערך עם כל מספרים איזוגיים: יחזיר 0
- מערך עם כל מספרים זוגיים: יחזיר את אורך המערך
- מערך באורך 1: יחזיר 1 (אם זוגי) או 0 (אם איזוגי)

### טעויות נפוצות:
1. **שכחה לעדכן `m` בסוף הלולאה** - אם הרצף הארוך ביותר נמצא בסוף המערך
2. **אתחול `m` מ-1 במקום 0** - יחזיר תוצאה שגויה למערך של כל אי-זוגיים
3. **אי-איפוס של `c` לאחר מציאת אי-זוגי** - יחזיר תוצאה שגויה
4. **בדיקת `c > m` בלא לבדוק אחרי הלולאה**

### דוגמאות בדיקה:
1. `{2, 4, 6, 8, 3, 1}` → 4 ✓
2. `{1, 3, 5, 7, 9, 11}` → 0 ✓
3. `{12, 6, 3, 17, 4, 5, 2, 8, 10, 13}` → 3 ✓
4. `{2, 4, 6, 8, 10}` → 5 ✓
5. `{1, 2, 1, 2, 1}` → 1 ✓

### סיכום:
הפעולה בודקת רצפים רציפים של מספרים זוגיים ומחזירה את האורך של הרצף הארוך ביותר. זה דורש יכולת לספור, להשוות, ולאתחל מחדש בין כל רצף.
- 4: רצף חדש, אורך 1
- 5: איזוגי → מחסום
- 2, 8, 10: רצף באורך 3 → זה הארוך!
- 13: איזוגי → מחסום
- **תוצאה: 3**

### אלגוריתם:

```java
public static int what(int[] arr) {
    int c = 0;      // רצף נוכחי
    int m = 0;      // אורך מקסימלי
    
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] % 2 == 0) {  // זוגי?
            c++;                 // הוסף לרצף
        } else {                 // איזוגי!
            if (c > m)           // הרצף סיים
                m = c;
            c = 0;               // אתחל רצף חדש
        }
    }
    if (c > m)                   // רצף בסוף המערך
        return c;
    return m;
}
```

**לוגיקה:**
1. ספור זוגיים רציפים בצהוב (c)
2. כשנתקל בארוגי:
   - בדוק אם הרצף הנוכחי הוא הגדול ביותר (c > m)
   - אם כן, עדכן את m
   - אתחל רצף חדש (c = 0)
3. בסוף המערך, בדוק עוד פעם (המערך עשוי להיגמר עם זוגיים)

### 🎯 מה להקפיד:

✅ **תנאים קצה:**
- מערך ריק: return 0
- כל ה-אי-זוגיים: return 0
- כל הזוגיים: return length
- זוגי יחיד: return 1
- סיום עם זוגיים: צריך בדיקה **אחרי** הלולאה!

✅ **טעויות נפוצות:**
1. **שכחה של בדיקה סופית** `if (c > m)` **אחרי** הלולאה
   - אם הרצף הארוך בסוף → יפספס!
2. **ביצוע `m = c` בתוך ה-if לא בעדכון** → חסר סדר
3. **לא אתחול c ל-0** → יחשב שגוי
4. **שכחה לאתחל c לאחר איזוגי** → יחבר רצפים
5. **בדיקת `c > m`** בלי **או `c == m`** → אם שוים, בוחרים את הראשון ✓

✅ **דוגמאות בדיקה:**
```
{2, 4, 6, 3, 8, 10}    → 3 (2,4,6)
{1, 3, 5}             → 0 (אין זוגיים)
{2, 4, 6, 8}          → 4 (הכל)
{2}                   → 1 (יחיד)
{2, 4, 1, 6, 8, 10}   → 3 (6,8,10)
```

---