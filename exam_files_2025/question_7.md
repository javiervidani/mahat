# שאלה 7

## שאלון 97104, קיץ תשפ"ה – 2025 – מועד א'

## שאלה 7 (15 נקודות)

נתונות ארבע פעולות:

```java
public static double one(int num) {
    return two(num, 0, 0);
}

private static double two(int num, int s, int c) {
    if (num == 0) return (double)s / c;
    return two(num / 10, s + (num % 10), c + 1);
}

public static int[] three(int[] arr, int p) {
    int n = arr.length;
    int[] temp = new int[n];
    four(arr, temp, 0, 0, n - 1, p);
    return temp;
}

private static void four(int[] arr, int[] temp, int k,
                         int left, int right, int p) {
    if (k < arr.length) {
        if (one(arr[k]) > one(arr[p])) {
            temp[right] = arr[k];
            four(arr, temp, k + 1, left, right - 1, p);
        } else {
            temp[left] = arr[k];
            four(arr, temp, k + 1, left + 1, right, p);
        }
    }
}
```

### א. (5 נק')

1. עקבו אחרי זימון הפעולה one(6123) ורשמו את תוצאת הזימון. יש להראות מעקב!
2. תנו דוגמה של מספר שלם וחיובי גדול מ-100 שעבורו הפעולה תחזיר ערך חמש.
3. מה מבצעת הפעולה one(num) עבור מספר שלם num?

### ב. (10 נק')

נתון המערך: `int[] a = {24, 126, 9, 35, 2684, 8941}`

1. עקבו אחרי זימון הפעולה three(a, 3) ורשמו מה תהיה תוצאת הזימון. יש להראות מעקב אחרי ביצוע הפעולה three, אין צורך להראות מעקב אחרי הפעולות one ו-two.
2. האם קיים ערך p שעבורו זימון הפעולה three(a, p) יגרום לשגיאה? הסבירו את תשובתכם.
3. תנו דוגמה של מערך arr בגודל שישה תאים כך שזימון הפעולה three(arr, p) יחזיר מערך זהה ל-arr עבור כל ערך p תקין. אם הדבר אינו אפשרי, הסבירו מדוע.
4. מה מבצעת הפעולה three(a, p) עבור מערך של מספרים שלמים arr וערך שלם p?

## פתרון

### סעיף א (5 נקודות)

#### 1. מעקב אחרי one(6123):

| קריאה | num  | s (sum of digits) | c (count of digits) |
|-------|------|-------------------|---------------------|
| 1     | 6123 | 0 + 3 = 3        | 0 + 1 = 1          |
| 2     | 612  | 3 + 2 = 5        | 1 + 1 = 2          |
| 3     | 61   | 5 + 1 = 6        | 2 + 1 = 3          |
| 4     | 6    | 6 + 6 = 12       | 3 + 1 = 4          |
| 5     | 0    | return 12 / 4 = **3.0** | |

**תוצאה: 3.0**

#### 2. דוגמה למספר שיחזיר 5:

**5546** תחזיר 5 (כי (5+5+4+6)/4 = 20/4 = 5.0)

#### 3. מה מבצעת הפעולה:

הפעולה מחשבת **ממוצע ספרות** המספר.

### סעיף ב (10 נקודות)

#### 1. מעקב אחרי three(a, 3):

```
int[] a = {24, 126, 9, 35, 2684, 8941};
int p = 3; // one(a[3]) = one(35) = (3+5)/2 = 4.0
```

| index k | value | one(value)        | one(p) = 4.0 | condition | temp location |
|---------|-------|-------------------|--------------|-----------|---------------|
| 0       | 24    | (2+4)/2 = 3.0    | < 4.0        | left ← 0  | temp[0] = 24  |
| 1       | 126   | (1+2+6)/3 = 3.0  | < 4.0        | left ← 1  | temp[1] = 126 |
| 2       | 9     | 9/1 = 9.0        | > 4.0        | right ← 5 | temp[5] = 9   |
| 3       | 35    | (3+5)/2 = 4.0    | == 4.0       | left ← 2  | temp[2] = 35  |
| 4       | 2684  | (2+6+8+4)/4 = 5.0| > 4.0        | right ← 4 | temp[4] = 2684|
| 5       | 8941  | (8+9+4+1)/4 = 5.5| > 4.0        | right ← 3 | temp[3] = 8941|

**temp = {24, 126, 35, 8941, 2684, 9}**

#### 2. שגיאה:

כן, שגיאה תתרחש אם p לא נמצא בטווח התקני של האינדקסים במערך, כלומר **p < 0** או **p ≥ a.length**

#### 3. דוגמה למערך זהה:

```java
int[] arr = {111, 111, 111, 111, 111, 111};
```
או
```java
int[] arr = {123, 114, 3320, 141, 312, 213};
```

כל מספר שהממוצע שלו זהה יישאר באותו מיקום יחסי.

#### 4. מה מבצעת הפעולה:

הפעולה **three(arr, p)** מחזירה מערך חדש, שבו כל המספרים ממוקמים מחדש בהתאם לממוצע הספרות של כל מספר בהשוואה לממוצע הספרות של המספר שנמצא במקום p במערך. **הקטנים ממוצב לפני והגדולים אחרי**.

---
## 📚 הסבר התרגיל – כיצד לפתור?

### מהי הבעיה?
**ממוצע ספרות** (digit average) מחושב כ: (סכום ספרות) / (מספר ספרות)

דוגמות:
- one(6123) → (6+1+2+3)/4 = 12/4 = **3.0**
- one(35) → (3+5)/2 = 8/2 = **4.0**

**מיון חלקי** לפי ממוצע: הקטנים מ-pivot לשמאל, הגדולים לימין

### שלבי פתרון:

**סעיף א - one(num) - ממוצע ספרות:**

**שלב 1 - הבנת הרקורסיה:**
```java
one(6123) 
  → two(6123, 0, 0)
    → two(612, 3, 1)         // 6123 % 10 = 3, 6123 / 10 = 612
    → two(61, 5, 2)          // 612 % 10 = 2, 612 / 10 = 61
    → two(6, 6, 3)           // 61 % 10 = 1, 61 / 10 = 6
    → two(0, 12, 4)          // 6 % 10 = 6, 6 / 10 = 0
    → return 12/4 = 3.0      // תנאי עצירה
```

**שלב 2 - תנאי עצירה:**
- כאשר `num == 0`: החזר `(double)s / c`

**שלב 3 - רקורסיה:**
- חילוץ ספרה: `num % 10`
- צבירת סכום: `s + (num % 10)`
- הגדלת מונה: `c + 1`
- קריאה רקורסיבית: `num / 10`

**סעיף ב - three(arr, p) - מיון:**

**שלב 1 - בחר pivot:**
```java
double pivotAvg = one(arr[p]);
```

**שלב 2 - פיצול:**
- משמאל (left ← 0): ערכים עם ממוצע < pivotAvg
- מימין (right ← n-1): ערכים עם ממוצע > pivotAvg
- שווה: להחזיק בצד כלשהו (הקוד בחר "שווה" = left)

**שלב 3 - מילוי mترتיب:**
```java
if (one(arr[k]) > one(arr[p])) {
    temp[right] = arr[k];    // גדול מ-pivot → לימין
    right--;
} else {
    temp[left] = arr[k];     // קטן/שווה → לשמאל
    left++;
}
```

### דגשים חשובים:
- **רקורסיה two**: צבירה של סכום ומונה, לא חישוב בכל קריאה
- **four היא רקורסיה אחורית** - קוראת לעצמה בשורה האחרונה
- **left ו-right עדכנים** - left++) או (right--)
- **temp משמש מערך זמני** - לבנייה של התוצאה

### תנאי קצה:
- num = 0: one(0) → 0/0 → שגיאה (NaN או division by zero)
- p < 0 או p >= arr.length: IndexOutOfBoundsException
- כל ערכי המערך בעלי ממוצע זהה: המערך יישאר ללא שינוי

### טעויות נפוצות:
1. **טעות בחישוב ממוצע**: שכחה לחלק בחוקם ספרות
2. **טעות בתנאי עצירה**: בדוק `num == 0`, לא `num < 0`
3. **בעיה ב-left/right**: אם לא מעדכנים כראוי, יופיעו חורים בתוצאה
4. **אי-יציאה מרקורסיה**: אם לא קוראים left++/right-- יהיה לולאה אינסופית
5. **p לא תקין**: לא בדיקה של טווח תקין עבור p

### דוגמות בדיקה:

**סעיף א:**
- one(111) → (1+1+1)/3 = 1.0 ✓
- one(12345) → (1+2+3+4+5)/5 = 15/5 = 3.0 ✓
- one(99) → (9+9)/2 = 9.0 ✓

**סעיף ב:**
- arr = {24, 126, 9, 35, 2684, 8941}, p = 3
- pivot = one(35) = 4.0
- קטן מ-4: 24 (3.0), 126 (3.0), 35 (4.0)
- גדול מ-4: 9 (9.0), 2684 (5.0), 8941 (5.5)
- תוצאה: {24, 126, 35, 8941, 2684, 9}

### סיבוכיות:
- **one**: O(log n) - מחלקים ב-10 כל קריאה
- **three**: O(n log n) בממוצע (partition יעיל)
- **four**: O(n) - עובר על כל איברים פעם אחת

### סיכום:
התרגיל בודק:
- **רקורסיה עם צבירה** (one ו-two)
- **רקורסיה עם מצב מורכב** (four עם left/right)
- **בנייה של מערך חדש** דרך מיון
- **חשבון מספרים וממוצעים**
}

private static void four(int[] arr, int[] temp, int k, 
                         int left, int right, double pivot) {
    if (k < arr.length) {
        if (one(arr[k]) > pivot) {  // גדול מ-pivot
            temp[right] = arr[k];
            four(arr, temp, k+1, left, right-1, pivot);
        } else {  // קטן או שוה
            temp[left] = arr[k];
            four(arr, temp, k+1, left+1, right, pivot);
        }
    }
}
```

**לוגיקה:**
1. one() חישוב ממוצע בחזרה עמוקה (שמור sum/count)
2. three() מיון שיטוג משני צדדים למערך temp
3. four() רקורסיה עם pointers left/right

### 🎯 מה להקפיד:

✅ **תנאים קצה:**
- num=0: סיום רקורסיה → החזר sum/count
- num בן ספרה אחת: עדיין צריך sum=num, count=1
- איבר עם avg שוה ל-pivot: שם ל-left (במגבלת הסדר)

✅ **טעויות נפוצות:**
1. **one() צריכה לחזיר double**, לא int!
   - `return (double)sum / count` לא `sum / count`
2. **בדיקה:** `one(arr[k]) > one(arr[p])` לא `one(arr[k]) >= ...`
   - בשוויון → שם ל-left (קטן או שוה)
3. **תנאי עצירה:** `if (k < arr.length)` בלבד
4. **two() תנאי עצירה:** `num == 0` לא `num >= 0`
5. **left/right pointers** צריכים **להיות מיוצאות** לפני/אחרי

✅ **דוגמאות בדיקה:**
```
one(6123):  (6+1+2+3)/4 = 3.0 ✓
one(35):    (3+5)/2 = 4.0 ✓
one(5):     5/1 = 5.0 ✓

three([24,126,9,35], p=1):
avg[1] = (1+2+6)/3 = 3.0
→ [24,126,35,9] (כאלה ≤3 משמאל, >3 מימין)
```

---