# שאלה 10 - פעולות רקורסיביות על מערכים
**ערך: 17 נקודות**  
**חלק ג' - בחר 2 מתוך 3 שאלות**

## תיאור השאלה

נתונות הפעולות הבאות: `what` ו-`secret`, ושתי פעולות עזר: `why` ו-`mystery`.

```java
public static void secret(int[] a, int s) {
    s %= a.length;
    mystery(a, 0, a.length - 1);
    mystery(a, 0, s - 1);
    mystery(a, s, a.length - 1);
}

public static void mystery(int[] a, int start, int end) {
    int temp;
    while (start < end) {
        temp = a[start];
        a[start] = a[end];
        a[end] = temp;
        start++;
        end--;
    }
}

public static void what(int[] a, int d) {
    why(a, d, 0);
}

public static void why(int[] a, int d, int i) {
    if (i < a.length) {
        int j = (i + d) % a.length;
        int rest = a[j];
        why(a, d, i + 1);
        a[i] = rest;
    }
}
```

נתון מערך `arr` של מספרים שלמים:

| 0  | 1  | 2  | 3  | 4  | 5  | 6  |
|----|----|----|----|----|----|----|
| 10 | 3  | 6  | 8  | 2  | 11 | 5  |

---

## סעיף א' (3 נקודות) - מעקב אחרי mystery

עקבו אחרי זימון הפעולה `mystery(arr, 1, 4)` ורשמו מה יהיה תוכן המערך אחרי הזימון.

### פתרון:

הפעולה `mystery(arr, start, end)` מבצעת **היפוך** של חלק מהמערך מאינדקס `start` עד אינדקס `end`.

**מצב לפני:**
```
[10, 3, 6, 8, 2, 11, 5]
```

**תהליך:**
- `start = 1, end = 4`: החלק להיפוך הוא `[3, 6, 8, 2]`
- שלב 1: החלף `arr[1]` ו-`arr[4]` → `[10, 2, 6, 8, 3, 11, 5]`
- שלב 2: `start = 2, end = 3`: החלף `arr[2]` ו-`arr[3]` → `[10, 2, 8, 6, 3, 11, 5]`
- שלב 3: `start = 3, end = 2`: תנאי `start < end` לא מתקיים, סיום

**תוצאה:**
```
[10, 2, 8, 6, 3, 11, 5]
```

---

## סעיף ב' (3 נקודות) - מעקב אחרי secret

עקבו אחרי זימון הפעולה `secret(arr, 3)` ורשמו מה יהיה תוכן המערך אחרי הזימון.

### פתרון:

**מצב לפני:**
```
[10, 3, 6, 8, 2, 11, 5]
```

**שלבי הפעולה:**

1. `s = 3 % 7 = 3`
2. `mystery(arr, 0, 6)` - היפוך כל המערך:
   ```
   [5, 11, 2, 8, 6, 3, 10]
   ```

3. `mystery(arr, 0, 2)` - היפוך החלק הראשון (אינדקסים 0-2):
   ```
   [2, 11, 5, 8, 6, 3, 10]
   ```

4. `mystery(arr, 3, 6)` - היפוך החלק השני (אינדקסים 3-6):
   ```
   [2, 11, 5, 10, 3, 6, 8]
   ```

**תוצאה:**
```
[2, 11, 5, 10, 3, 6, 8]
```

---

## סעיף ג' (2 נקודות) - הסבר secret

מה מבצעת הפעולה `secret(a, d)` עבור מערך של מספרים שלמים `a` ומספר שלם וחיובי `d`?

### פתרון:

הפונקציה `secret(a, d)` מבצעת **סיבוב שמאלה** (left rotation) של המערך ב-`d` מקומות.

**אלגוריתם:**
הפונקציה משתמשת בטכניקת **שלושה היפוכים**:
1. היפוך של כל המערך
2. היפוך של החלק הראשון (מאינדקס 0 עד `d-1`)
3. היפוך של החלק השני (מאינדקס `d` עד הסוף)

**דוגמה:**
- מערך: `[1, 2, 3, 4, 5]`
- סיבוב שמאלה ב-2 מקומות: `[3, 4, 5, 1, 2]`

---

## סעיף ד' (3 נקודות) - מעקב רקורסיבי אחרי what

עקבו אחרי זימון הפעולה `what(arr, 3)` על המערך ההתחלתי ורשמו מה יהיה תוכן המערך אחרי הזימון.

**יש להראות ערכי המשתנים בכל זימון רקורסיבי.**

### פתרון:

**מצב לפני:**
```
[10, 3, 6, 8, 2, 11, 5]
```

**שלבי הרקורסיה (`why(a, 3, i)`):**

| קריאה | i | j = (i+3)%7 | rest = a[j] | פעולה                          |
|-------|---|-------------|-------------|--------------------------------|
| 1     | 0 | 3           | 8           | שמירת 8, קריאה רקורסיבית      |
| 2     | 1 | 4           | 2           | שמירת 2, קריאה רקורסיבית      |
| 3     | 2 | 5           | 11          | שמירת 11, קריאה רקורסיבית     |
| 4     | 3 | 6           | 5           | שמירת 5, קריאה רקורסיבית      |
| 5     | 4 | 0           | 10          | שמירת 10, קריאה רקורסיבית     |
| 6     | 5 | 1           | 3           | שמירת 3, קריאה רקורסיבית      |
| 7     | 6 | 2           | 6           | שמירת 6, קריאה רקורסיבית      |
| 8     | 7 | -           | -           | `i >= a.length` - תנאי עצירה  |

**שלב חזור (backtracking):**
כעת הקריאות חוזרות בסדר הפוך ומעדכנות את המערך:
- `a[6] = 6`
- `a[5] = 3`
- `a[4] = 10`
- `a[3] = 5`
- `a[2] = 11`
- `a[1] = 2`
- `a[0] = 8`

**תוצאה:**
```
[8, 2, 11, 5, 10, 3, 6]
```

---

## סעיף ה' (3 נקודות) - הנדסה לאחור

לאחר זימון הפעולה `what(brr, 2)` מתקבל המערך `brr` הזה:

```
[60, 50, 40, 30, 20, 10]
```

**מה היה תוכן המערך `brr` לפני זימון הפעולה?**

### פתרון:

הפעולה `what(a, 2)` מבצעת סיבוב **ימינה** ב-2 מקומות.

כדי למצוא את המערך המקורי, נבצע סיבוב **שמאלה** ב-2 מקומות:

**תוצאה לאחר `what(brr, 2)`:**
```
[60, 50, 40, 30, 20, 10]
```

**חישוב לאחור:**
אם `what` מסובב ימינה ב-2, אז המקור יהיה סיבוב שמאלה ב-2:

| אינדקס בתוצאה | ערך | ← | אינדקס במקור |
|---------------|-----|---|--------------|
| 0             | 60  | ← | 4            |
| 1             | 50  | ← | 5            |
| 2             | 40  | ← | 0            |
| 3             | 30  | ← | 1            |
| 4             | 20  | ← | 2            |
| 5             | 10  | ← | 3            |

**המערך המקורי:**
```
[40, 30, 20, 10, 60, 50]
```

**בדיקה:**
- `what([40, 30, 20, 10, 60, 50], 2)` → סיבוב ימינה ב-2 → `[60, 50, 40, 30, 20, 10]` ✓

---

## סעיף ו' (3 נקודות) - הסבר what

מה מבצעת הפעולה `what(a, d)` עבור מערך של מספרים שלמים `a` ומספר שלם וחיובי `d`?

### פתרון:

הפעולה `what(a, d)` יוצרת **סיבוב ימינה** (right rotation) של המערך ב-`d` מקומות.

**אלגוריתם:**
- הפעולה משתמשת ברקורסיה
- בכל קריאה רקורסיבית, שומרת ערך מאינדקס `(i + d) % length`
- בשלב החזור, מעתיקה את הערכים השמורים למיקומים החדשים

**דוגמה:**
- מערך: `[1, 2, 3, 4, 5]`
- סיבוב ימינה ב-2 מקומות: `[4, 5, 1, 2, 3]`

**הבדל בין `secret` ו-`what`:**
- `secret(a, d)` - סיבוב **שמאלה**
- `what(a, d)` - סיבוב **ימינה**

---

## סיכום קוד מלא

```java
public class ArrayRotations {
    
    // סיבוב שמאלה באמצעות 3 היפוכים
    public static void secret(int[] a, int s) {
        s %= a.length;
        mystery(a, 0, a.length - 1);
        mystery(a, 0, s - 1);
        mystery(a, s, a.length - 1);
    }
    
    // היפוך חלק מהמערך
    public static void mystery(int[] a, int start, int end) {
        int temp;
        while (start < end) {
            temp = a[start];
            a[start] = a[end];
            a[end] = temp;
            start++;
            end--;
        }
    }
    
    // סיבוב ימינה באמצעות רקורסיה
    public static void what(int[] a, int d) {
        why(a, d, 0);
    }
    
    // פעולת עזר רקורסיבית לסיבוב ימינה
    public static void why(int[] a, int d, int i) {
        if (i < a.length) {
            int j = (i + d) % a.length;
            int rest = a[j];
            why(a, d, i + 1);
            a[i] = rest;
        }
    }
    
    // פעולת עזר להדפסת מערך
    public static void printArray(int[] arr) {
        System.out.print("[");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i]);
            if (i < arr.length - 1) System.out.print(", ");
        }
        System.out.println("]");
    }
    
    public static void main(String[] args) {
        int[] arr1 = {10, 3, 6, 8, 2, 11, 5};
        System.out.print("מקורי: ");
        printArray(arr1);
        
        mystery(arr1, 1, 4);
        System.out.print("אחרי mystery(arr, 1, 4): ");
        printArray(arr1);
        
        int[] arr2 = {10, 3, 6, 8, 2, 11, 5};
        secret(arr2, 3);
        System.out.print("אחרי secret(arr, 3): ");
        printArray(arr2);
        
        int[] arr3 = {10, 3, 6, 8, 2, 11, 5};
        what(arr3, 3);
        System.out.print("אחרי what(arr, 3): ");
        printArray(arr3);
    }
}
```

---

## סיבוכיות

### mystery (היפוך)
- **זמן**: O(n) - כאשר n הוא אורך הטווח להיפוך
- **מקום**: O(1) - ללא שימוש בזיכרון נוסף

### secret (סיבוב שמאלה)
- **זמן**: O(n) - שלושה היפוכים, כל אחד O(n)
- **מקום**: O(1) - ללא שימוש בזיכרון נוסף

### what (סיבוב ימינה רקורסיבי)
- **זמן**: O(n) - כל איבר נבדק פעם אחת
- **מקום**: O(n) - עומק הרקורסיה

---

## סיכום

השאלה בודקת:
- ✅ הבנת פעולות רקורסיביות
- ✅ מעקב אחרי ביצוע אלגוריתמים
- ✅ הבנת סיבובי מערכים
- ✅ טכניקת היפוכים לסיבוב
- ✅ יכולת הנדסה לאחור
- ✅ ניתוח סיבוכיות
## 📚 הסבר התרגיל – כיצד לפתור?

### מהי הבעיה?
יש לנתח ולהבין פעולות רקורסיביות ואיטרטיביות שמבצעות סיבובים (rotations) והיפוכים (reversals) על מערכים. נדרש לעקוב אחרי ערכי המערך בשלבים שונים, להבין מה כל פונקציה עושה, ולזהות את ההבדלים בין סיבוב שמאלה, ימינה, והיפוך חלקי.

### שלבי פתרון (אלגוריתם):
1. קרא בעיון את הקוד – זהה אילו פרמטרים משתנים בכל קריאה.
2. עבור mystery – עקוב אחרי ערכי start, end, ומה קורה בכל איטרציה (היפוך חלקי).
3. עבור secret – הבן את שלבי שלושת ההיפוכים, ומה המשמעות של כל שלב (סיבוב שמאלה).
4. עבור what/why – עקוב אחרי הקריאות הרקורסיביות, מה נשמר ומה מתעדכן (סיבוב ימינה).
5. עבור כל סעיף – כתוב טבלה/תרשים של ערכי המערך בשלבים שונים.

### דגשים חשובים:
- mystery – מבצע היפוך של תת-מערך (מאינדקס start עד end).
- secret – מבצע סיבוב שמאלה ב-d מקומות ע"י שלושה היפוכים.
- what/why – מבצע סיבוב ימינה ב-d מקומות ע"י רקורסיה והעתקה.
- יש להיזהר מטעויות off-by-one (למשל, start < end).
- יש לעקוב אחרי ערכי המערך לפני ואחרי כל שלב.

### תנאי קצה:
- מערך ריק או בגודל 1
- סיבוב ב-0 מקומות (המערך לא משתנה)
- סיבוב בגודל המערך (חוזר לעצמו)
- סיבוב גדול מגודל המערך (שימוש ב-% length)

### טעויות נפוצות:
- בלבול בין סיבוב שמאלה לימינה
- שכחת לעדכן start/end בלולאה
- קריאה רקורסיבית לא נכונה (למשל, i+1 במקום i-1)
- שכחת תנאי עצירה ברקורסיה
- אי-בדיקת קלטים קיצוניים (מערך ריק, d=0)

### דוגמאות בדיקה:
1. mystery(arr, 1, 4) – בדוק את המערך לפני, אחרי כל החלפה, ואחרי הסיום.
2. secret(arr, 3) – כתוב את המערך אחרי כל שלב (היפוך כללי, היפוך ראשון, היפוך שני).
3. what(arr, 3) – עקוב אחרי ערכי i, j, ומה נשמר בכל שלב רקורסיבי.
4. נסה סיבוב ב-0, ב-1, בגודל המערך, ובערכים שליליים.

### איך לבדוק את עצמך?
- כתוב טבלה של ערכי המערך בשלבים שונים.
- נסה להריץ את הקוד על מערכים קצרים (3-5 איברים) ולבדוק ידנית.
- בדוק קלטים קיצוניים (מערך ריק, d=0, d=length).
- נסה להבין מה קורה כאשר d גדול מהאורך (שימוש ב-%).

### סיכום:
התרגיל דורש הבנה עמוקה של רקורסיה, לולאות, סיבובי מערכים, וניתוח שלבי ביצוע. חשוב להקפיד על מעקב אחרי ערכים, בדיקת תנאי קצה, והבנה של כל שלב באלגוריתם.