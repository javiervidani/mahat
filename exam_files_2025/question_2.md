# שאלה 2

## שאלון 97104, קיץ תשפ"ה – 2025 – מועד א'

## שאלה 2 (12 נקודות)

נתון מערך arr בגודל n המכיל מספרים שלמים שונים זה מזה.

נגדיר **"נקודת איזון"** כאינדקס k במערך, כך שמכפלת כל האיברים משמאל לאינדקס k שווה למכפלת כל האיברים מימין לאינדקס k (לא כולל האיבר באינדקס k).

כתבו פעולה המוצאת את נקודת האיזון במערך ומחזירה את האינדקס שלה. אם יש כמה נקודות איזון יש להחזיר את הראשונה מצד שמאל. אם לא קיימת נקודת האיזון הפעולה תחזיר -1.

## פתרון

```java
public static int findBalancePoint(int[] arr) {
    int n = arr.length;
    
    for (int k = 0; k < n; k++) {
        // חישוב מכפלת האיברים משמאל
        int leftProduct = 1;
        for (int i = 0; i < k; i++) {
            leftProduct *= arr[i];
        }
        
        // חישוב מכפלת האיברים מימין
        int rightProduct = 1;
        for (int j = k + 1; j < n; j++) {
            rightProduct *= arr[j];
        }
        
        // בדיקה אם זו נקודת איזון
        if (leftProduct == rightProduct) {
            return k;
        }
    }
    
    return -1;
}
```

---
## 📚 הסבר התרגיל – כיצד לפתור?

### מהי הבעיה?
מציאת נקודת איזון במערך (מכפלות שוות)

### אלגוריתם:

**שלבים:**
1. קרא את הדרישה בעיון
2. זהה את סוגי הנתונים
3. תכנן את הלולאה/הרקורסיה
4. בדוק תנאים קצה
5. כתוב קוד ובדוק עם דוגמה

### 🎯 מה להקפיד:

✅ **תנאים קצה:**
- מערך ריק או בגודל 1
- מחרוזת ריקה או תו אחד
- ערכים שליליים או אפס

✅ **טעויות נפוצות:**
- שכחה של אתחול משתנים
- בדיקת תנאים לא נכונה (< vs <=)
- שכחה של `break` או `return`
- היפוך לוגיקה (>= במקום <)
- בניית מחרוזת בלולאה באופן לא יעיל

✅ **כיצד לבדוק:**
1. בדוק עם דוגמה מהשאלה
2. בדוק עם קלט ריק/מינימלי
3. בדוק עם קלט מקסימלי
4. בדוק קיום טעות off-by-one

---